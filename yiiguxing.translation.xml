<application>
  <component name="AppStorage">
    <histories>
      <item value="能力" />
      <item value="dispose Org Ver Task" />
      <item value="停止使用" />
      <item value="prohibit" />
      <item value="禁止" />
      <item value="停用" />
      <item value="javax.validation.ConstraintDeclarationException: HV000151: A method overriding another method must not redefine the parameter constraint configuration, but method TestServiceImpl#param(String, String) redefines the configuration of TestService#param(String, String). at org.hibernate.validator.internal.metadata.aggregated.rule.OverridingMethodMustNotAlterParameterConstraints.apply(OverridingMethodMustNotAlterParameterConstraints.java:24) at org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.assertCorrectnessOfConfiguration(ExecutableMetaData.java:461) at org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData$Builder.build(ExecutableMetaData.java:377) at org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataImpl$BuilderDelegate.build(BeanMetaDataImpl.java:788) at org.hibernate.validator.internal.metadata.aggregated.BeanMetaDataImpl$BeanMetaDataBuilder.build(BeanMetaDataImpl.java:648) at org.hibernate.validator.internal.metadata.BeanMetaDataManager.createBeanMetaData(BeanMetaDataManager.java:192) at org.hibernate.validator.internal.metadata.BeanMetaDataManager.lambda$getBeanMetaData$0(BeanMetaDataManager.java:160) at java.util.concurrent.ConcurrentMap.computeIfAbsent(ConcurrentMap.java:324) at org.hibernate.validator.internal.metadata.BeanMetaDataManager.getBeanMetaData(BeanMetaDataManager.java:159) at org.hibernate.validator.internal.engine.ValidationContext$ValidationContextBuilder.forValidateParameters(ValidationContext.java:619) at org.hibernate.validator.internal.engine.ValidatorImpl.validateParameters(ValidatorImpl.java:254) at org.hibernate.validator.internal.engine.ValidatorImpl.validateParameters(ValidatorImpl.java:224)" />
      <item value="Set the ApplicationContext that this object runs in. * Normally this call will be used to initialize the object. * &lt;p&gt;Invoked after population of normal bean properties but before an init callback such * as {@link org.springframework.beans.factory.InitializingBean#afterPropertiesSet()} * or a custom init-method. Invoked after {@link ResourceLoaderAware#setResourceLoader}, * {@link ApplicationEventPublisherAware#setApplicationEventPublisher} and * {@link MessageSourceAware}, if applicable." />
      <item value="Set the ApplicationContext that this object runs in. * Normally this call will be used to initialize the object. * &lt;p&gt;Invoked after population of normal bean properties but before an init callback such * as {@link org.springframework.beans.factory.InitializingBean#afterPropertiesSet()} * or a custom init-method. Invoked after {@link ResourceLoaderAware#setResourceLoader}," />
      <item value="Interface to be implemented by any object that wishes to be notified * of the {@link ApplicationContext} that it runs in." />
      <item value="one or more hint objects to be passed to the validation engine" />
      <item value="* Validate the supplied {@code target} object, which must be of a type of {@link Class} * for which the {@link #supports(Class)} method typically returns {@code true}. * &lt;p&gt;The supplied {@link Errors errors} instance can be used to report any * resulting validation errors. * &lt;p&gt;&lt;b&gt;This variant of {@code validate()} supports validation hints, such as * validation groups against a JSR-303 provider&lt;/b&gt; (in which case, the provided hint * objects need to be annotation arguments of type {@code Class}). * &lt;p&gt;Note: Validation hints may get ignored by the actual target {@code Validator}, * in which case this method should behave just like its regular" />
      <item value="* Validate the supplied value for the specified field on the target type, * reporting the same validation errors as if the value would be bound to * the field on an instance of the target class." />
      <item value="* Support a current transaction, execute non-transactionally if none exists. * Analogous to EJB transaction attribute of the same name. * &lt;p&gt;Note: For transaction managers with transaction synchronization, * PROPAGATION_SUPPORTS is slightly different from no transaction at all, * as it defines a transaction scope that synchronization will apply for. * As a consequence, the same resources (JDBC Connection, Hibernate Session, etc) * will be shared for the entire specified scope. Note that this depends on * the actual synchronization configuration of the transaction manager. * @see org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization */" />
      <item value="* Analogous to EJB transaction attribute of the same name. * &lt;p&gt;Note: For transaction managers with transaction synchronization, * PROPAGATION_SUPPORTS is slightly different from no transaction at all, * as it defines a transaction scope that synchronization will apply for. * As a consequence, the same resources (JDBC Connection, Hibernate Session, etc) * will be shared for the entire specified scope. Note that this depends on * the actual synchronization configuration of the transaction manager. * @see org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization */" />
      <item value="* Support a current transaction, throw an exception if none exists. * Analogous to EJB transaction attribute of the same name. */" />
      <item value="* Create a new transaction, and suspend the current transaction if one exists. * Analogous to the EJB transaction attribute of the same name. * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Actual transaction suspension will not work out-of-the-box * on all transaction managers. This in particular applies to * {@link org.springframework.transaction.jta.JtaTransactionManager}, * which requires the {@code javax.transaction.TransactionManager} to be * made available to it (which is server-specific in standard Java EE). * @see org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager */" />
      <item value="* Execute non-transactionally, suspend the current transaction if one exists. * Analogous to EJB transaction attribute of the same name. * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Actual transaction suspension will not work out-of-the-box * on all transaction managers. This in particular applies to * {@link org.springframework.transaction.jta.JtaTransactionManager}, * which requires the {@code javax.transaction.TransactionManager} to be * made available to it (which is server-specific in standard Java EE). * @se" />
      <item value="* Execute within a nested transaction if a current transaction exists, * behave like PROPAGATION_REQUIRED else. There is no analogous feature in EJB. * &lt;p&gt;Note: Actual creation of a nested transaction will only work on specific * transaction managers. Out of the box, this only applies to the JDBC * DataSourceTransactionManager when working on a JDBC 3.0 driver. * Some JTA providers might support nested transactions as well." />
      <item value="* Support a current transaction, throw an exception if none exists. * Analogous to EJB transaction attribute of the same name." />
      <item value="* Support a current transaction, execute non-transactionally if none exists. * Analogous to EJB transaction attribute of the same name. * &lt;p&gt;Note: For transaction managers with transaction synchronization, * PROPAGATION_SUPPORTS is slightly different from no transaction at all, * as it defines a transaction scope that synchronization will apply for. * As a consequence, the same resources (JDBC Connection, Hibernate Session, etc) * will be shared for the entire specified scope. Note that this depends on * the actual synchronization configuration of the transaction manager." />
      <item value="* &lt;p&gt;Can be used e.g. with Spring MVC handler methods arguments. * Supported through {@link org.springframework.validation.SmartValidator}'s * validation hint concept, with validation group classes acting as hint objects." />
      <item value="* &lt;p&gt;Can also be used with method level validation, indicating that a specific * class is supposed to be validated at the method level (acting as a pointcut * for the corresponding validation interceptor), but also optionally specifying * the validation groups for method-level validation in the annotated class. * Applying this annotation at the method level allows for overriding the * validation groups for a specific method but does not serve as a pointcut; * a class-level annotation is nevertheless necessary to trigger method validation * for a specific bean to begin with. Can also be used as a meta-annotation on a * custom stereotype annotation or a custom group-specific validated annotation. *" />
      <item value="* Get the method argument values for the current request, checking the provided * argument values and falling back to the configured argument resolvers. * &lt;p&gt;The resulting array will be passed into {@link #doInvoke}." />
      <item value="fail Cause" />
      <item value="不合格原因" />
      <item value="依据" />
      <item value="结论" />
      <item value="Async" />
      <item value="* {@link javax.servlet.Filter} that converts posted method parameters into HTTP methods, * retrievable via {@link HttpServletRequest#getMethod()}. Since browsers currently only * support GET and POST, a common technique - used by the Prototype library, for instance - * is to use a normal POST with an additional hidden form field ({@code _method}) * to pass the &quot;real&quot; HTTP method along. This filter reads that parameter and changes * the {@link HttpServletRequestWrapper#getMethod()} return value accordingly. * Only {@code &quot;PUT&quot;}, {@code &quot;DELETE&quot;} and {@code &quot;PATCH&quot;} HTTP methods are allowed. * * &lt;p&gt;The name of the request parameter defaults to {@code _method}, but can be * adapted via the {@link #setMethodParam(String) methodParam} property. * * &lt;p&gt;&lt;b&gt;NOTE: This filter needs to run after multipart processing in case of a multipart * POST request, due to its inherent need for checking a POST body parameter.&lt;/b&gt; * So typically, put a Spring {@link org.springframework.web.multipart.support.MultipartFilter} * &lt;i&gt;before&lt;/i&gt; this HiddenHttpMethodFilter in your {@code web.xml} filter chain." />
      <item value="* Indicates that a class provides Spring Boot application * {@link Configuration @Configuration}. Can be used as an alternative to the Spring's * standard {@code @Configuration} annotation so that configuration can be found * automatically (for example in tests). * &lt;p&gt; * Application should only ever include &lt;em&gt;one&lt;/em&gt; {@code @SpringBootConfiguration} and * most idiomatic Spring Boot applications will inherit it from * {@code @SpringBootApplication}." />
      <item value="/** * Indicates that a class provides Spring Boot application * {@link Configuration @Configuration}. Can be used as an alternative to the Spring's * standard {@code @Configuration} annotation so that configuration can be found * automatically (for example in tests). * &lt;p&gt; * Application should only ever include &lt;em&gt;one&lt;/em&gt; {@code @SpringBootConfiguration} and * most idiomatic Spring Boot applications will inherit it from * {@code @SpringBootApplication}." />
      <item value="Path pattern used for static resources." />
      <item value="* Postfix the error code at the end of the generated message code. e.g.:" />
      <item value="* Formatting strategy for message codes. For instance, `PREFIX_ERROR_CODE`." />
      <item value="* With the introduction of async processing and the possibility of * non-container threads calling sendError() tracking the current error * state and ensuring that the correct error page is called becomes more * complicated. This state attribute helps by tracking the current error * state and informing callers that attempt to change state if the change * was successful or if another thread got there first." />
      <item value="is Error Report Required" />
      <item value="* Select the appropriate child Context to process this request, * based on the specified request URI. If no matching Context can * be found, return an appropriate HTTP error." />
      <item value="* Handle the HTTP status code (and corresponding message) generated * while processing the specified Request to produce the specified * Response. Any exceptions that occur during generation of the error * report are logged and swallowed. *" />
      <item value="Primarily" />
      <item value="indicate" />
      <item value="Once Per Request Filter" />
      <item value="* Specify if the condition should match if the property is not set. Defaults to * {@code false}. * @return if should match if the property is missing" />
      <item value="Conditional" />
      <item value="anonymous users" />
      <item value="攀登者" />
      <item value="Cache Manager" />
      <item value="* Hint for that an {@link EnableAutoConfiguration auto-configuration} should be applied * after other specified auto-configuration classes." />
      <item value="Unsatisfied" />
      <item value="{@link CacheManager} implementation that lazily builds {@link ConcurrentMapCache} * instances for each {@link #getCache} request. Also supports a 'static' mode where * the set of cache names is pre-defined through {@link #setCacheNames}, with no * dynamic creation of further cache regions at runtime." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="362" />
        <entry key="ENGLISH" value="362" />
        <entry key="BOSNIAN" value="1" />
        <entry key="DANISH" value="3" />
        <entry key="GERMAN" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="LITHUANIAN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190917000334998" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="fanyi.baidu" />
  </component>
</application>