<application>
  <component name="AppStorage">
    <histories>
      <item value="激活" />
      <item value="Specify one or more validation groups to apply to the validation step * kicked off by this annotation. * &lt;p&gt;JSR-303 defines validation groups as custom annotations which an application declares * for the sole purpose of using them as type-safe group arguments, as implemented in * {@link org.springframework.validation.beanvalidation.SpringValidatorAdapter}. * &lt;p&gt;Other {@link org.springframework.validation.SmartValidator} implementations may * support class arguments in other ways as well." />
      <item value="Variant of JSR-303's {@link javax.validation.Valid}, supporting the * specification of validation groups. Designed for convenient use with * Spring's JSR-303 support but not JSR-303 specific. * * &lt;p&gt;Can be used e.g. with Spring MVC handler methods arguments. * Supported through {@link org.springframework.validation.SmartValidator}'s * validation hint concept, with validation group classes acting as hint objects. * * &lt;p&gt;Can also be used with method level validation, indicating that a specific * class is supposed to be validated at the method level (acting as a pointcut * for the corresponding validation interceptor), but also optionally specifying * the validation groups for method-level validation in the annotated class. * Applying this annotation at the method level allows for overriding the * validation groups for a specific method but does not serve as a pointcut; * a class-level annotation is nevertheless necessary to trigger method validation * for a specific bean to begin with. Can also be used as a meta-annotation on a * custom stereotype annotation or a custom group-specific validated annotation. *" />
      <item value="性别" />
      <item value="身份证号" />
      <item value="身份证" />
      <item value="完善" />
      <item value="transitive" />
      <item value="An opinionated {@link WebApplicationInitializer} to run a {@link SpringApplication} * from a traditional WAR deployment. Binds {@link Servlet}, {@link Filter} and * {@link ServletContextInitializer} beans from the application context to the server. * &lt;p&gt; * To configure the application either override the * {@link #configure(SpringApplicationBuilder)} method (calling * {@link SpringApplicationBuilder#sources(Class...)}) or make the initializer itself a * {@code @Configuration}. If you are using {@link SpringBootServletInitializer} in * combination with other {@link WebApplicationInitializer WebApplicationInitializers} you * might also want to add an {@code @Ordered} annotation to configure a specific startup * order. * &lt;p&gt; * Note that a WebApplicationInitializer is only needed if you are building a war file and * deploying it. If you prefer to run an embedded web server then you won't need this at * all." />
      <item value="Filter" />
      <item value="类别" />
      <item value="area Code" />
      <item value="Purpose" />
      <item value="chartmanager" />
      <item value="多线程" />
      <item value="Exists" />
      <item value="Exist" />
      <item value="A boolean flag that can be set to {@code true} if the transaction is * effectively read-only, allowing for corresponding optimizations at runtime. * &lt;p&gt;Defaults to {@code false}. * &lt;p&gt;This just serves as a hint for the actual transaction subsystem; * it will &lt;i&gt;not necessarily&lt;/i&gt; cause failure of write access attempts. * A transaction manager which cannot interpret the read-only hint will * &lt;i&gt;not&lt;/i&gt; throw an exception when asked for a read-only transaction * but rather silently ignore the hint." />
      <item value="The default behavior is as with EJB: rollback on unchecked exception * ({@link RuntimeException}), assuming an unexpected outcome outside of any * business rules. Additionally, we also attempt to rollback on {@link Error} which * is clearly an unexpected outcome as well. By contrast, a checked exception is * considered a business exception and therefore a regular expected outcome of the * transactional business method, i.e. a kind of alternative return value which * still allows for regular completion of resource operations. * &lt;p&gt;This is largely consistent with TransactionTemplate's default behavior, * except that TransactionTemplate also rolls back on undeclared checked exceptions * (a corner case). For declarative transactions, we expect checked exceptions to be * intentionally declared as business exceptions, leading to a commit by default. * @see org.springframework.transaction.support.TransactionTemplate#execute" />
      <item value="Defines zero (0) or more exception {@link Class classes}, which must be * subclasses of {@link Throwable}, indicating which exception types must cause * a transaction rollback. * &lt;p&gt;By default, a transaction will be rolling back on {@link RuntimeException} * and {@link Error} but not on checked exceptions (business exceptions). See * {@link org.springframework.transaction.interceptor.DefaultTransactionAttribute#rollbackOn(Throwable)} * for a detailed explanation. * &lt;p&gt;This is the preferred way to construct a rollback rule (in contrast to * {@link #rollbackForClassName}), matching the exception class and its subclasses. * &lt;p&gt;Similar to {@link org.springframework.transaction.interceptor.RollbackRuleAttribute#RollbackRuleAttribute(Class clazz)}. * @see #rollbackForClassName * @see org.springframework.transaction.interceptor.DefaultTransactionAttribute#rollbackOn(Throwable) */" />
      <item value="Set the transaction rollback-only. This instructs the transaction manager * that the only possible outcome of the transaction may be a rollback, as * alternative to throwing an exception which would in turn trigger a rollback. * &lt;p&gt;This is mainly intended for transactions managed by * {@link org.springframework.transaction.support.TransactionTemplate} or * {@link org.springframework.transaction.interceptor.TransactionInterceptor}, * where the actual commit/rollback decision is made by the container. * @see org.springframework.transaction.support.TransactionCallback#doInTransaction * @see org.springframework.transaction.interceptor.TransactionAttribute#rollbackOn" />
      <item value="Hash Set" />
      <item value="Comparison of compare method result with specific constant" />
      <item value="三表导出模板" />
      <item value="* Represents a predicate (boolean-valued function) of one argument." />
      <item value="enhance" />
      <item value="non-private to simplify nested class access" />
      <item value="The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added." />
      <item value="delta-seconds" />
      <item value="delta" />
      <item value="null unless explicitly set" />
      <item value="一次" />
      <item value="Onece" />
      <item value="This method is inherently unsafe. Stopping a thread with * Thread.stop causes it to unlock all of the monitors that it * has locked (as a natural consequence of the unchecked * &lt;code&gt;ThreadDeath&lt;/code&gt; exception propagating up the stack). If * any of the objects previously protected by these monitors were in * an inconsistent state, the damaged objects become visible to * other threads, potentially resulting in arbitrary behavior. Many * uses of &lt;code&gt;stop&lt;/code&gt; should be replaced by code that simply * modifies some variable to indicate that the target thread should * stop running. The target thread should check this variable * regularly, and return from its run method in an orderly fashion * if the variable indicates that it is to stop running. If the * target thread waits for long periods (on a condition variable, * for example), the &lt;code&gt;interrupt&lt;/code&gt; method should be used to * interrupt the wait. * For more information, see * &lt;a href=&quot;{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html&quot;&gt;Why * are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;. */" />
      <item value="Wrong" />
      <item value="This is often the result of over-eager type matching - consider using 'getBeanNamesOf" />
      <item value="This means that said other beans do not use the final version of the bean." />
      <item value="its raw version as part of a circular reference, but has eventually been wrapped" />
      <item value="asynchronous" />
      <item value="* Adds a response header with the given name and value. This method allows * response headers to have multiple values." />
      <item value="* Sets a response header with the given name and value. If the header had * already been set, the new value overwrites the previous one. The * &lt;code&gt;containsHeader&lt;/code&gt; method can be used to test for the presence * of a header before setting its value." />
      <item value="Laws Regulations" />
      <item value="街道" />
      <item value="Productor" />
      <item value="stop Produce" />
      <item value="暂停等待" />
      <item value="暂停" />
      <item value="* The current thread must own this object's monitor. The thread * releases ownership of this monitor and waits until another thread * notifies threads waiting on this object's monitor to wake up * either through a call to the {@code notify} method or the * {@code notifyAll} method. The thread then waits until it can * re-obtain ownership of the monitor and resumes execution." />
      <item value="The current thread must own this object's monitor. The thread * releases ownership of this monitor and waits until another thread * notifies threads waiting on this object's monitor to wake up * either through a call to the {@code notify} method or the * {@code notifyAll} method. The thread then waits until it can * re-obtain ownership of the monitor and resumes execution." />
      <item value="behaves" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="450" />
        <entry key="ENGLISH" value="450" />
        <entry key="BOSNIAN" value="1" />
        <entry key="DANISH" value="5" />
        <entry key="GERMAN" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FINNISH" value="2" />
        <entry key="CATALAN" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="LITHUANIAN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SPANISH" value="3" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190917000334998" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="fanyi.baidu" />
  </component>
</application>