<application>
  <component name="AppStorage">
    <histories>
      <item value="Whether to resolve the multipart request lazily at the time of file or parameter * access" />
      <item value="dir Sprator" />
      <item value="compatibility" />
      <item value="multiplier" />
      <item value="entire" />
      <item value="counter" />
      <item value="durable" />
      <item value="* &lt;p&gt;Checks if none of the CharSequences are blank (&quot;&quot;) or null and whitespace only..&lt;/p&gt;" />
      <item value="answer" />
      <item value="Indicates" />
      <item value="scale of the {@code BigDecimal}. * @return a {@code BigDecimal} whose value is * &lt;tt&gt;(unscaledVal &amp;times; 10&lt;sup&gt;-scale&lt;/sup&gt;)&lt;/tt&gt;." />
      <item value="EMBEDDED" />
      <item value="集成" />
      <item value="intergration" />
      <item value="* The {@code Void} class is an uninstantiable placeholder class to hold a * reference to the {@code Class} object representing the Java keyword * void." />
      <item value="duplicate" />
      <item value="attempted" />
      <item value="is Exceed" />
      <item value="/** * Splits {@code sequence} into string components and returns them as an immutable list. If you * want an {@link Iterable} which may be lazily evaluated, use {@link #split(CharSequence)}. * * @param sequence the sequence of characters to split * @return an immutable list of the segments split from the parameter * @since 15.0 */" />
      <item value="Beta" />
      <item value="分裂器" />
      <item value="split" />
      <item value="签名" />
      <item value="sign Contract" />
      <item value="signed Up" />
      <item value="SUFFIX" />
      <item value="EXCEL SUFFIX" />
      <item value="* Requests that the file or directory denoted by this abstract * pathname be deleted when the virtual machine terminates. * Files (or directories) are deleted in the reverse order that * they are registered. Invoking this method to delete a file or * directory that is already registered for deletion has no effect. * Deletion will be attempted only for normal termination of the * virtual machine, as defined by the Java Language Specification. *" />
      <item value="附件" />
      <item value="attach" />
      <item value="* Reads a class file from the source and returns a reference * to the &lt;code&gt;CtClass&lt;/code&gt; * object representing that class file. If that class file has been * already read, this method returns a reference to the * &lt;code&gt;CtClass&lt;/code&gt; created when that class file was read at the * first time." />
      <item value="Compilation" />
      <item value="* Set the timeout to use for receive calls, in &lt;b&gt;milliseconds&lt;/b&gt;. * The default is 1000 ms, that is, 1 second. * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; This value needs to be smaller than the transaction * timeout used by the transaction manager (in the appropriate unit, * of course). 0 indicates no timeout at all; however, this is only * feasible if not running within a transaction manager and generally * discouraged since such a listener container cannot cleanly shut down. * A negative value such as -1 indicates a no-wait receive operation." />
      <item value="* Only acknowledge an individual message - using message.acknowledge() * as opposed to CLIENT_ACKNOWLEDGE which * acknowledges all messages consumed by a session at when acknowledge() * is called" />
      <item value="receive message" />
      <item value="* @return the reply, possibly {@code null} if the message could not be received, * for example due to a timeout" />
      <item value="Expiring" />
      <item value="* Add Service and Referenceable and TransportListener to @link{org.apache.activemq.jms.pool.PooledConnectionFactory}" />
      <item value="* A ConnectionFactory is an an Administered object, and is used for creating * Connections. &lt;p/&gt; This class also implements QueueConnectionFactory and * TopicConnectionFactory. You can use this connection to create both * QueueConnections and TopicConnections." />
      <item value="Blocking period before throwing an exception if the pool is still full." />
      <item value="* Whether a PooledConnectionFactory should be created, instead of a regular * ConnectionFactory." />
      <item value="preinit" />
      <item value="* Whether the default destination type is topic." />
      <item value="Topic Definition" />
      <item value="A {@code Destination} object encapsulates a provider-specific * address. * The JMS API does not define a standard address syntax. Although a standard * address syntax was considered, it was decided that the differences in * address semantics between existing message-oriented middleware (MOM) * products were too wide to bridge with a single syntax. * * &lt;P&gt;Since {@code Destination} is an administered object, it may * contain * provider-specific configuration information in addition to its address. * * &lt;P&gt;The JMS API also supports a client's use of provider-specific address * names. * * &lt;P&gt;{@code Destination} objects support concurrent use. * * &lt;P&gt;A {@code Destination} object is a JMS administered object. * * &lt;P&gt;JMS administered objects are objects containing configuration * information that are created by an administrator and later used by * JMS clients. They make it practical to administer the JMS API in the * enterprise. * * &lt;P&gt;Although the interfaces for administered objects do not explicitly * depend on the Java Naming and Directory Interface (JNDI) API, the JMS API * establishes the convention that JMS clients find administered objects by * looking them up in a JNDI namespace. * * &lt;P&gt;An administrator can place an administered object anywhere in a * namespace. The JMS API does not define a naming policy. * * &lt;P&gt;It is expected that JMS providers will provide the tools an * administrator needs to create and configure administered objects in a * JNDI namespace. JMS provider implementations of administered objects * should implement the {@code javax.naming.Referenceable} and * {@code java.io.Serializable} interfaces so that they can be stored in * all JNDI naming contexts. In addition, it is recommended that these * implementations follow the JavaBeans&lt;SUP&gt;&lt;FONT SIZE=&quot;-2&quot;&gt;TM&lt;/FONT&gt;&lt;/SUP&gt; * design patterns. * * &lt;P&gt;This strategy provides several benefits: * * &lt;UL&gt; * &lt;LI&gt;It hides provider-specific details from JMS clients. * &lt;LI&gt;It abstracts JMS administrative information into objects in the Java * programming language (&quot;Java objects&quot;) * that are easily organized and administered from a common * management console. * &lt;LI&gt;Since there will be JNDI providers for all popular naming * services, JMS providers can deliver one implementation * of administered objects that will run everywhere. * &lt;/UL&gt; * * &lt;P&gt;An administered object should not hold on to any remote resources. * Its lookup should not use remote resources other than those used by the * JNDI API itself. * * &lt;P&gt;Clients should think of administered objects as local Java objects. * Looking them up should not have any hidden side effects or use surprising * amounts of local resources. *" />
      <item value="覆盖" />
      <item value="With this acknowledgment mode, the client acknowledges a consumed * message by calling the message's {@code acknowledge} method. * Acknowledging a consumed message acknowledges all messages that the * session has consumed. * * &lt;P&gt;When client acknowledgment mode is used, a client may build up a * large number of unacknowledged messages while attempting to process * them. A JMS provider should provide administrators with a way to * limit client overrun so that clients are not driven to resource * exhaustion and ensuing failure when some resource they are using * is temporarily blocked." />
      <item value="Set the priority of a message when sending. * &lt;p&gt;Since a default value may be defined administratively, * this is only used when &quot;isExplicitQosEnabled&quot; equals &quot;true&quot;." />
      <item value="Whether to stop message delivery before re-delivering messages from a rolled back * transaction. This implies that message order is not preserved when this is enabled. */" />
      <item value="Time to wait before considering a close complete." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="222" />
        <entry key="ENGLISH" value="223" />
        <entry key="BOSNIAN" value="1" />
        <entry key="DANISH" value="2" />
        <entry key="RUSSIAN" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="LITHUANIAN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
  </component>
</application>