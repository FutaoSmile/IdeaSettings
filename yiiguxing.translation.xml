<application>
  <component name="AppStorage">
    <histories>
      <item value="* &lt;p&gt;Can be used e.g. with Spring MVC handler methods arguments. * Supported through {@link org.springframework.validation.SmartValidator}'s * validation hint concept, with validation group classes acting as hint objects." />
      <item value="* &lt;p&gt;Can also be used with method level validation, indicating that a specific * class is supposed to be validated at the method level (acting as a pointcut * for the corresponding validation interceptor), but also optionally specifying * the validation groups for method-level validation in the annotated class. * Applying this annotation at the method level allows for overriding the * validation groups for a specific method but does not serve as a pointcut; * a class-level annotation is nevertheless necessary to trigger method validation * for a specific bean to begin with. Can also be used as a meta-annotation on a * custom stereotype annotation or a custom group-specific validated annotation. *" />
      <item value="* Get the method argument values for the current request, checking the provided * argument values and falling back to the configured argument resolvers. * &lt;p&gt;The resulting array will be passed into {@link #doInvoke}." />
      <item value="fail Cause" />
      <item value="不合格原因" />
      <item value="依据" />
      <item value="结论" />
      <item value="Async" />
      <item value="* {@link javax.servlet.Filter} that converts posted method parameters into HTTP methods, * retrievable via {@link HttpServletRequest#getMethod()}. Since browsers currently only * support GET and POST, a common technique - used by the Prototype library, for instance - * is to use a normal POST with an additional hidden form field ({@code _method}) * to pass the &quot;real&quot; HTTP method along. This filter reads that parameter and changes * the {@link HttpServletRequestWrapper#getMethod()} return value accordingly. * Only {@code &quot;PUT&quot;}, {@code &quot;DELETE&quot;} and {@code &quot;PATCH&quot;} HTTP methods are allowed. * * &lt;p&gt;The name of the request parameter defaults to {@code _method}, but can be * adapted via the {@link #setMethodParam(String) methodParam} property. * * &lt;p&gt;&lt;b&gt;NOTE: This filter needs to run after multipart processing in case of a multipart * POST request, due to its inherent need for checking a POST body parameter.&lt;/b&gt; * So typically, put a Spring {@link org.springframework.web.multipart.support.MultipartFilter} * &lt;i&gt;before&lt;/i&gt; this HiddenHttpMethodFilter in your {@code web.xml} filter chain." />
      <item value="* Indicates that a class provides Spring Boot application * {@link Configuration @Configuration}. Can be used as an alternative to the Spring's * standard {@code @Configuration} annotation so that configuration can be found * automatically (for example in tests). * &lt;p&gt; * Application should only ever include &lt;em&gt;one&lt;/em&gt; {@code @SpringBootConfiguration} and * most idiomatic Spring Boot applications will inherit it from * {@code @SpringBootApplication}." />
      <item value="/** * Indicates that a class provides Spring Boot application * {@link Configuration @Configuration}. Can be used as an alternative to the Spring's * standard {@code @Configuration} annotation so that configuration can be found * automatically (for example in tests). * &lt;p&gt; * Application should only ever include &lt;em&gt;one&lt;/em&gt; {@code @SpringBootConfiguration} and * most idiomatic Spring Boot applications will inherit it from * {@code @SpringBootApplication}." />
      <item value="Path pattern used for static resources." />
      <item value="* Postfix the error code at the end of the generated message code. e.g.:" />
      <item value="* Formatting strategy for message codes. For instance, `PREFIX_ERROR_CODE`." />
      <item value="* With the introduction of async processing and the possibility of * non-container threads calling sendError() tracking the current error * state and ensuring that the correct error page is called becomes more * complicated. This state attribute helps by tracking the current error * state and informing callers that attempt to change state if the change * was successful or if another thread got there first." />
      <item value="is Error Report Required" />
      <item value="* Select the appropriate child Context to process this request, * based on the specified request URI. If no matching Context can * be found, return an appropriate HTTP error." />
      <item value="* Handle the HTTP status code (and corresponding message) generated * while processing the specified Request to produce the specified * Response. Any exceptions that occur during generation of the error * report are logged and swallowed. *" />
      <item value="Primarily" />
      <item value="indicate" />
      <item value="Once Per Request Filter" />
      <item value="* Specify if the condition should match if the property is not set. Defaults to * {@code false}. * @return if should match if the property is missing" />
      <item value="Conditional" />
      <item value="anonymous users" />
      <item value="攀登者" />
      <item value="Cache Manager" />
      <item value="* Hint for that an {@link EnableAutoConfiguration auto-configuration} should be applied * after other specified auto-configuration classes." />
      <item value="Unsatisfied" />
      <item value="{@link CacheManager} implementation that lazily builds {@link ConcurrentMapCache} * instances for each {@link #getCache} request. Also supports a 'static' mode where * the set of cache names is pre-defined through {@link #setCacheNames}, with no * dynamic creation of further cache regions at runtime." />
      <item value="Implementation" />
      <item value="Cognitive Complexity of methods should not be too high Code smell Critical squid:S3776 Cognitive Complexity is a measure of how hard the control flow of a method is to understand. Methods with high Cognitive Complexity will be difficult to maintain. See Cognitive Complexity" />
      <item value="Cognitive Complexity of methods should not be too high Code smell Critical&#10;squid:S3776 Cognitive Complexity is a measure of how hard the control flow of a method is to understand. Methods with high Cognitive Complexity will be difficult to maintain.&#10;See&#10;Cognitive Complexity" />
      <item value="Declarations should use Java collection interfaces such as &quot;List&quot; rather than specific implementation classes such as &quot;LinkedList&quot; Code smell Minor squid:S1319 The purpose of the Java Collections API is to provide a well defined hierarchy of interfaces in order to hide implementation details. Implementing classes must be used to instantiate new collections, but the result of an instantiation should ideally be stored in a variable whose type is a Java Collection interface. This rule raises an issue when an implementation class: is returned from a public method. is accepted as an argument to a public method. is exposed as a public member. Noncompliant Code Example  public class Employees {    private HashSet&lt;Employee&gt; employees = new HashSet&lt;Employee&gt;(); // Noncompliant - &quot;employees&quot; should have type &quot;Set&quot; rather than &quot;HashSet&quot;      public HashSet&lt;Employee&gt; getEmployees() { // Noncompliant      return employees;    }  }   Compliant Solution  public class Employees {    private Set&lt;Employee&gt; employees = new HashSet&lt;Employee&gt;(); // Compliant      public Set&lt;Employee&gt; getEmployees() { // Compliant      return employees;    }  }" />
      <item value="Declarations should use Java collection interfaces such as &quot;List&quot; rather than specific implementation classes such as &quot;LinkedList&quot; Code smell Minor&#10;squid:S1319 The purpose of the Java Collections API is to provide a well defined hierarchy of interfaces in order to hide implementation details.&#10;Implementing classes must be used to instantiate new collections, but the result of an instantiation should ideally be stored in a variable whose type is a Java Collection interface.&#10;This rule raises an issue when an implementation class:&#10;is returned from a public method.&#10;is accepted as an argument to a public method.&#10;is exposed as a public member.&#10;Noncompliant Code Example  public class Employees {    private HashSet&lt;Employee&gt; employees = new HashSet&lt;Employee&gt;(); // Noncompliant - &quot;employees&quot; should have type &quot;Set&quot; rather than &quot;HashSet&quot;      public HashSet&lt;Employee&gt; getEmployees() { // Noncompliant      return employees;    }  }  &#10;Compliant Solution  public class Employees {    private Set&lt;Employee&gt; employees = new HashSet&lt;Employee&gt;(); // Compliant      public Set&lt;Employee&gt; getEmployees() { // Compliant      return employees;    }  }" />
      <item value="无效" />
      <item value="有效" />
      <item value="检定" />
      <item value="不合格" />
      <item value="合格" />
      <item value="expiry Date" />
      <item value="录入" />
      <item value="Org Check Result Controller" />
      <item value="less invasive" />
      <item value="A lookup method causes the IoC container to override the given method and return the bean with the name given in the bean attribute. This is a form of Method Injection. It is particularly useful as an alternative to implementing the BeanFactoryAware interface, in order to be able to make getBean() calls for non-singleton instances at runtime. In this case, Method Injection is a less invasive alternative." />
      <item value="Can be used to create one or more aliases illegal in an (XML) id. Multiple aliases can be separated by any number of spaces, commas, or semi-colons (or indeed any mixture of the three)." />
      <item value="recurse" />
      <item value="* @return the number of bean definitions found" />
      <item value="resolved" />
      <item value="typically" />
      <item value="消息摘要" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="342" />
        <entry key="ENGLISH" value="343" />
        <entry key="BOSNIAN" value="1" />
        <entry key="DANISH" value="3" />
        <entry key="RUSSIAN" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="LITHUANIAN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190917000334998" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="fanyi.baidu" />
  </component>
</application>