<application>
  <component name="AppStorage">
    <histories>
      <item value="one or more hint objects to be passed to the validation engine" />
      <item value="* Validate the supplied {@code target} object, which must be of a type of {@link Class} * for which the {@link #supports(Class)} method typically returns {@code true}. * &lt;p&gt;The supplied {@link Errors errors} instance can be used to report any * resulting validation errors. * &lt;p&gt;&lt;b&gt;This variant of {@code validate()} supports validation hints, such as * validation groups against a JSR-303 provider&lt;/b&gt; (in which case, the provided hint * objects need to be annotation arguments of type {@code Class}). * &lt;p&gt;Note: Validation hints may get ignored by the actual target {@code Validator}, * in which case this method should behave just like its regular" />
      <item value="* Validate the supplied value for the specified field on the target type, * reporting the same validation errors as if the value would be bound to * the field on an instance of the target class." />
      <item value="* Support a current transaction, execute non-transactionally if none exists. * Analogous to EJB transaction attribute of the same name. * &lt;p&gt;Note: For transaction managers with transaction synchronization, * PROPAGATION_SUPPORTS is slightly different from no transaction at all, * as it defines a transaction scope that synchronization will apply for. * As a consequence, the same resources (JDBC Connection, Hibernate Session, etc) * will be shared for the entire specified scope. Note that this depends on * the actual synchronization configuration of the transaction manager. * @see org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization */" />
      <item value="* Analogous to EJB transaction attribute of the same name. * &lt;p&gt;Note: For transaction managers with transaction synchronization, * PROPAGATION_SUPPORTS is slightly different from no transaction at all, * as it defines a transaction scope that synchronization will apply for. * As a consequence, the same resources (JDBC Connection, Hibernate Session, etc) * will be shared for the entire specified scope. Note that this depends on * the actual synchronization configuration of the transaction manager. * @see org.springframework.transaction.support.AbstractPlatformTransactionManager#setTransactionSynchronization */" />
      <item value="* Support a current transaction, throw an exception if none exists. * Analogous to EJB transaction attribute of the same name. */" />
      <item value="* Create a new transaction, and suspend the current transaction if one exists. * Analogous to the EJB transaction attribute of the same name. * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Actual transaction suspension will not work out-of-the-box * on all transaction managers. This in particular applies to * {@link org.springframework.transaction.jta.JtaTransactionManager}, * which requires the {@code javax.transaction.TransactionManager} to be * made available to it (which is server-specific in standard Java EE). * @see org.springframework.transaction.jta.JtaTransactionManager#setTransactionManager */" />
      <item value="* Execute non-transactionally, suspend the current transaction if one exists. * Analogous to EJB transaction attribute of the same name. * &lt;p&gt;&lt;b&gt;NOTE:&lt;/b&gt; Actual transaction suspension will not work out-of-the-box * on all transaction managers. This in particular applies to * {@link org.springframework.transaction.jta.JtaTransactionManager}, * which requires the {@code javax.transaction.TransactionManager} to be * made available to it (which is server-specific in standard Java EE). * @se" />
      <item value="* Execute within a nested transaction if a current transaction exists, * behave like PROPAGATION_REQUIRED else. There is no analogous feature in EJB. * &lt;p&gt;Note: Actual creation of a nested transaction will only work on specific * transaction managers. Out of the box, this only applies to the JDBC * DataSourceTransactionManager when working on a JDBC 3.0 driver. * Some JTA providers might support nested transactions as well." />
      <item value="* Support a current transaction, throw an exception if none exists. * Analogous to EJB transaction attribute of the same name." />
      <item value="* Support a current transaction, execute non-transactionally if none exists. * Analogous to EJB transaction attribute of the same name. * &lt;p&gt;Note: For transaction managers with transaction synchronization, * PROPAGATION_SUPPORTS is slightly different from no transaction at all, * as it defines a transaction scope that synchronization will apply for. * As a consequence, the same resources (JDBC Connection, Hibernate Session, etc) * will be shared for the entire specified scope. Note that this depends on * the actual synchronization configuration of the transaction manager." />
      <item value="* &lt;p&gt;Can be used e.g. with Spring MVC handler methods arguments. * Supported through {@link org.springframework.validation.SmartValidator}'s * validation hint concept, with validation group classes acting as hint objects." />
      <item value="* &lt;p&gt;Can also be used with method level validation, indicating that a specific * class is supposed to be validated at the method level (acting as a pointcut * for the corresponding validation interceptor), but also optionally specifying * the validation groups for method-level validation in the annotated class. * Applying this annotation at the method level allows for overriding the * validation groups for a specific method but does not serve as a pointcut; * a class-level annotation is nevertheless necessary to trigger method validation * for a specific bean to begin with. Can also be used as a meta-annotation on a * custom stereotype annotation or a custom group-specific validated annotation. *" />
      <item value="* Get the method argument values for the current request, checking the provided * argument values and falling back to the configured argument resolvers. * &lt;p&gt;The resulting array will be passed into {@link #doInvoke}." />
      <item value="fail Cause" />
      <item value="不合格原因" />
      <item value="依据" />
      <item value="结论" />
      <item value="Async" />
      <item value="* {@link javax.servlet.Filter} that converts posted method parameters into HTTP methods, * retrievable via {@link HttpServletRequest#getMethod()}. Since browsers currently only * support GET and POST, a common technique - used by the Prototype library, for instance - * is to use a normal POST with an additional hidden form field ({@code _method}) * to pass the &quot;real&quot; HTTP method along. This filter reads that parameter and changes * the {@link HttpServletRequestWrapper#getMethod()} return value accordingly. * Only {@code &quot;PUT&quot;}, {@code &quot;DELETE&quot;} and {@code &quot;PATCH&quot;} HTTP methods are allowed. * * &lt;p&gt;The name of the request parameter defaults to {@code _method}, but can be * adapted via the {@link #setMethodParam(String) methodParam} property. * * &lt;p&gt;&lt;b&gt;NOTE: This filter needs to run after multipart processing in case of a multipart * POST request, due to its inherent need for checking a POST body parameter.&lt;/b&gt; * So typically, put a Spring {@link org.springframework.web.multipart.support.MultipartFilter} * &lt;i&gt;before&lt;/i&gt; this HiddenHttpMethodFilter in your {@code web.xml} filter chain." />
      <item value="* Indicates that a class provides Spring Boot application * {@link Configuration @Configuration}. Can be used as an alternative to the Spring's * standard {@code @Configuration} annotation so that configuration can be found * automatically (for example in tests). * &lt;p&gt; * Application should only ever include &lt;em&gt;one&lt;/em&gt; {@code @SpringBootConfiguration} and * most idiomatic Spring Boot applications will inherit it from * {@code @SpringBootApplication}." />
      <item value="/** * Indicates that a class provides Spring Boot application * {@link Configuration @Configuration}. Can be used as an alternative to the Spring's * standard {@code @Configuration} annotation so that configuration can be found * automatically (for example in tests). * &lt;p&gt; * Application should only ever include &lt;em&gt;one&lt;/em&gt; {@code @SpringBootConfiguration} and * most idiomatic Spring Boot applications will inherit it from * {@code @SpringBootApplication}." />
      <item value="Path pattern used for static resources." />
      <item value="* Postfix the error code at the end of the generated message code. e.g.:" />
      <item value="* Formatting strategy for message codes. For instance, `PREFIX_ERROR_CODE`." />
      <item value="* With the introduction of async processing and the possibility of * non-container threads calling sendError() tracking the current error * state and ensuring that the correct error page is called becomes more * complicated. This state attribute helps by tracking the current error * state and informing callers that attempt to change state if the change * was successful or if another thread got there first." />
      <item value="is Error Report Required" />
      <item value="* Select the appropriate child Context to process this request, * based on the specified request URI. If no matching Context can * be found, return an appropriate HTTP error." />
      <item value="* Handle the HTTP status code (and corresponding message) generated * while processing the specified Request to produce the specified * Response. Any exceptions that occur during generation of the error * report are logged and swallowed. *" />
      <item value="Primarily" />
      <item value="indicate" />
      <item value="Once Per Request Filter" />
      <item value="* Specify if the condition should match if the property is not set. Defaults to * {@code false}. * @return if should match if the property is missing" />
      <item value="Conditional" />
      <item value="anonymous users" />
      <item value="攀登者" />
      <item value="Cache Manager" />
      <item value="* Hint for that an {@link EnableAutoConfiguration auto-configuration} should be applied * after other specified auto-configuration classes." />
      <item value="Unsatisfied" />
      <item value="{@link CacheManager} implementation that lazily builds {@link ConcurrentMapCache} * instances for each {@link #getCache} request. Also supports a 'static' mode where * the set of cache names is pre-defined through {@link #setCacheNames}, with no * dynamic creation of further cache regions at runtime." />
      <item value="Implementation" />
      <item value="Cognitive Complexity of methods should not be too high Code smell Critical squid:S3776 Cognitive Complexity is a measure of how hard the control flow of a method is to understand. Methods with high Cognitive Complexity will be difficult to maintain. See Cognitive Complexity" />
      <item value="Cognitive Complexity of methods should not be too high Code smell Critical&#10;squid:S3776 Cognitive Complexity is a measure of how hard the control flow of a method is to understand. Methods with high Cognitive Complexity will be difficult to maintain.&#10;See&#10;Cognitive Complexity" />
      <item value="Declarations should use Java collection interfaces such as &quot;List&quot; rather than specific implementation classes such as &quot;LinkedList&quot; Code smell Minor squid:S1319 The purpose of the Java Collections API is to provide a well defined hierarchy of interfaces in order to hide implementation details. Implementing classes must be used to instantiate new collections, but the result of an instantiation should ideally be stored in a variable whose type is a Java Collection interface. This rule raises an issue when an implementation class: is returned from a public method. is accepted as an argument to a public method. is exposed as a public member. Noncompliant Code Example  public class Employees {    private HashSet&lt;Employee&gt; employees = new HashSet&lt;Employee&gt;(); // Noncompliant - &quot;employees&quot; should have type &quot;Set&quot; rather than &quot;HashSet&quot;      public HashSet&lt;Employee&gt; getEmployees() { // Noncompliant      return employees;    }  }   Compliant Solution  public class Employees {    private Set&lt;Employee&gt; employees = new HashSet&lt;Employee&gt;(); // Compliant      public Set&lt;Employee&gt; getEmployees() { // Compliant      return employees;    }  }" />
      <item value="Declarations should use Java collection interfaces such as &quot;List&quot; rather than specific implementation classes such as &quot;LinkedList&quot; Code smell Minor&#10;squid:S1319 The purpose of the Java Collections API is to provide a well defined hierarchy of interfaces in order to hide implementation details.&#10;Implementing classes must be used to instantiate new collections, but the result of an instantiation should ideally be stored in a variable whose type is a Java Collection interface.&#10;This rule raises an issue when an implementation class:&#10;is returned from a public method.&#10;is accepted as an argument to a public method.&#10;is exposed as a public member.&#10;Noncompliant Code Example  public class Employees {    private HashSet&lt;Employee&gt; employees = new HashSet&lt;Employee&gt;(); // Noncompliant - &quot;employees&quot; should have type &quot;Set&quot; rather than &quot;HashSet&quot;      public HashSet&lt;Employee&gt; getEmployees() { // Noncompliant      return employees;    }  }  &#10;Compliant Solution  public class Employees {    private Set&lt;Employee&gt; employees = new HashSet&lt;Employee&gt;(); // Compliant      public Set&lt;Employee&gt; getEmployees() { // Compliant      return employees;    }  }" />
      <item value="无效" />
      <item value="有效" />
      <item value="检定" />
      <item value="不合格" />
      <item value="合格" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="354" />
        <entry key="ENGLISH" value="355" />
        <entry key="BOSNIAN" value="1" />
        <entry key="DANISH" value="3" />
        <entry key="RUSSIAN" value="1" />
        <entry key="CATALAN" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="LITHUANIAN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190917000334998" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="fanyi.baidu" />
  </component>
</application>