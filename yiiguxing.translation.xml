<application>
  <component name="AppStorage">
    <histories>
      <item value="多线程" />
      <item value="Exists" />
      <item value="Exist" />
      <item value="A boolean flag that can be set to {@code true} if the transaction is * effectively read-only, allowing for corresponding optimizations at runtime. * &lt;p&gt;Defaults to {@code false}. * &lt;p&gt;This just serves as a hint for the actual transaction subsystem; * it will &lt;i&gt;not necessarily&lt;/i&gt; cause failure of write access attempts. * A transaction manager which cannot interpret the read-only hint will * &lt;i&gt;not&lt;/i&gt; throw an exception when asked for a read-only transaction * but rather silently ignore the hint." />
      <item value="The default behavior is as with EJB: rollback on unchecked exception * ({@link RuntimeException}), assuming an unexpected outcome outside of any * business rules. Additionally, we also attempt to rollback on {@link Error} which * is clearly an unexpected outcome as well. By contrast, a checked exception is * considered a business exception and therefore a regular expected outcome of the * transactional business method, i.e. a kind of alternative return value which * still allows for regular completion of resource operations. * &lt;p&gt;This is largely consistent with TransactionTemplate's default behavior, * except that TransactionTemplate also rolls back on undeclared checked exceptions * (a corner case). For declarative transactions, we expect checked exceptions to be * intentionally declared as business exceptions, leading to a commit by default. * @see org.springframework.transaction.support.TransactionTemplate#execute" />
      <item value="Defines zero (0) or more exception {@link Class classes}, which must be * subclasses of {@link Throwable}, indicating which exception types must cause * a transaction rollback. * &lt;p&gt;By default, a transaction will be rolling back on {@link RuntimeException} * and {@link Error} but not on checked exceptions (business exceptions). See * {@link org.springframework.transaction.interceptor.DefaultTransactionAttribute#rollbackOn(Throwable)} * for a detailed explanation. * &lt;p&gt;This is the preferred way to construct a rollback rule (in contrast to * {@link #rollbackForClassName}), matching the exception class and its subclasses. * &lt;p&gt;Similar to {@link org.springframework.transaction.interceptor.RollbackRuleAttribute#RollbackRuleAttribute(Class clazz)}. * @see #rollbackForClassName * @see org.springframework.transaction.interceptor.DefaultTransactionAttribute#rollbackOn(Throwable) */" />
      <item value="Set the transaction rollback-only. This instructs the transaction manager * that the only possible outcome of the transaction may be a rollback, as * alternative to throwing an exception which would in turn trigger a rollback. * &lt;p&gt;This is mainly intended for transactions managed by * {@link org.springframework.transaction.support.TransactionTemplate} or * {@link org.springframework.transaction.interceptor.TransactionInterceptor}, * where the actual commit/rollback decision is made by the container. * @see org.springframework.transaction.support.TransactionCallback#doInTransaction * @see org.springframework.transaction.interceptor.TransactionAttribute#rollbackOn" />
      <item value="Hash Set" />
      <item value="Comparison of compare method result with specific constant" />
      <item value="三表导出模板" />
      <item value="* Represents a predicate (boolean-valued function) of one argument." />
      <item value="enhance" />
      <item value="non-private to simplify nested class access" />
      <item value="The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added." />
      <item value="delta-seconds" />
      <item value="delta" />
      <item value="null unless explicitly set" />
      <item value="一次" />
      <item value="Onece" />
      <item value="This method is inherently unsafe. Stopping a thread with * Thread.stop causes it to unlock all of the monitors that it * has locked (as a natural consequence of the unchecked * &lt;code&gt;ThreadDeath&lt;/code&gt; exception propagating up the stack). If * any of the objects previously protected by these monitors were in * an inconsistent state, the damaged objects become visible to * other threads, potentially resulting in arbitrary behavior. Many * uses of &lt;code&gt;stop&lt;/code&gt; should be replaced by code that simply * modifies some variable to indicate that the target thread should * stop running. The target thread should check this variable * regularly, and return from its run method in an orderly fashion * if the variable indicates that it is to stop running. If the * target thread waits for long periods (on a condition variable, * for example), the &lt;code&gt;interrupt&lt;/code&gt; method should be used to * interrupt the wait. * For more information, see * &lt;a href=&quot;{@docRoot}/../technotes/guides/concurrency/threadPrimitiveDeprecation.html&quot;&gt;Why * are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;. */" />
      <item value="Wrong" />
      <item value="This is often the result of over-eager type matching - consider using 'getBeanNamesOf" />
      <item value="This means that said other beans do not use the final version of the bean." />
      <item value="its raw version as part of a circular reference, but has eventually been wrapped" />
      <item value="asynchronous" />
      <item value="* Adds a response header with the given name and value. This method allows * response headers to have multiple values." />
      <item value="* Sets a response header with the given name and value. If the header had * already been set, the new value overwrites the previous one. The * &lt;code&gt;containsHeader&lt;/code&gt; method can be used to test for the presence * of a header before setting its value." />
      <item value="Laws Regulations" />
      <item value="街道" />
      <item value="Productor" />
      <item value="stop Produce" />
      <item value="暂停等待" />
      <item value="暂停" />
      <item value="* The current thread must own this object's monitor. The thread * releases ownership of this monitor and waits until another thread * notifies threads waiting on this object's monitor to wake up * either through a call to the {@code notify} method or the * {@code notifyAll} method. The thread then waits until it can * re-obtain ownership of the monitor and resumes execution." />
      <item value="The current thread must own this object's monitor. The thread * releases ownership of this monitor and waits until another thread * notifies threads waiting on this object's monitor to wake up * either through a call to the {@code notify} method or the * {@code notifyAll} method. The thread then waits until it can * re-obtain ownership of the monitor and resumes execution." />
      <item value="behaves" />
      <item value="invokes" />
      <item value="A method overriding another method must not redefine the parameter constraint configuration" />
      <item value="Todo" />
      <item value="manager Task Impl Mapper" />
      <item value="count Todo" />
      <item value="un Read Count" />
      <item value="un Read" />
      <item value="练习" />
      <item value="li" />
      <item value="given fairness policy" />
      <item value="reentrant Lock" />
      <item value="Reentrant Lock" />
      <item value="* &amp;#64;SneakyThrow does not silently swallow, wrap into RuntimeException, or otherwise modify any exceptions of the listed * checked exception types. The JVM does not check for the consistency of the checked exception system; javac does, * and this annotation lets you opt out of its mechanism." />
      <item value="* &lt;p&gt; * &amp;#64;SneakyThrow does not silently swallow, wrap into RuntimeException, or otherwise modify any exceptions of the listed * checked exception types. The JVM does not check for the consistency of the checked exception system; javac does," />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="439" />
        <entry key="ENGLISH" value="439" />
        <entry key="BOSNIAN" value="1" />
        <entry key="DANISH" value="5" />
        <entry key="GERMAN" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FINNISH" value="2" />
        <entry key="CATALAN" value="1" />
        <entry key="CROATIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="LITHUANIAN" value="1" />
        <entry key="ROMANIAN" value="3" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="PORTUGUESE" value="1" />
        <entry key="SWEDISH" value="2" />
        <entry key="SPANISH" value="3" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20190917000334998" />
        <option name="appKeyConfigured" value="true" />
      </app-key>
    </option>
    <option name="ignoreRegExp" value="" />
    <option name="translator" value="fanyi.baidu" />
  </component>
</application>